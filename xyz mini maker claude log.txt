xyz mini maker pinter is no longer supported by manufacturer. review and analyze to understand the miniMover tool as you will be build using this knowledge or adding to the project. Here are readme docs https://github.com/reality-boy/miniMover/tree/master/docs  (miniMover is a project that lets you send GCode to an XYZ da Vinci printer. It will also convert from a .3w file to .gcode and back, and can monitor and setup the printer as well. This works with newer printers that implement the version 3 serial protocol. These include the Nano, Mini W, miniMaker and Jr. line of printers among others.
You can read up on the development progress in this forum.
__http://www.soliforum.com/topic/17028/print-gcode-files-to-minimaker/__
This works with the following printers over a USB connection. There is limited wireless support but it is not fully functional yet.
da Vinci nano da Vinci nano w da Vinci miniMaker da Vinci mini w da Vinci mini wA da Vinci mini w+ da Vinci Jr. 1.0 da Vinci Jr. 1.0W da Vinci Jr. 1.0A da Vinci Jr. 1.0 3in1 da Vinci Jr. 1.0 3in1 (Open filament) da Vinci Jr. 1.0 Pro da Vinci Jr. 1.0W Pro da Vinci Jr. 2.0 Mix da Vinci 1.0 Pro da Vinci 1.0 Pro 3in1 da Vinci 1.0 Super
With these printers I can only convert from gcode to 3w files and back. They use an older communication protocol that I have not implemented yet, so I can't send data to them directly.
da Vinci 1.0 da Vinci 1.0A da Vinci 1.0 AiO da Vinci 1.1 Plus *** May partially work over usb *** da Vinci 2.0 Duo da Vinci 2.0A Duo
This comes in two flavors, a win32 GUI and a command line utility.

Here is a summary of the commands that the command line can take.

usage: miniMover <args> [file]
  file - print file if .gcode, otherwise convert to gcode if .3w
  -d devName - set serial port device name or wifi ip address, -1 auto detects port
  -po devName - set serial port device name, -1 auto detects port
  -c file - convert file
  -p file - print file
  -f file - upload firmware, experimental!
  -r - print raw status
  -s - print status
  -? - print help message

 * The following only work on machines that lack an LCD *

  -a+ - enable auto level
  -a- - disable auto level
  -b+ - enable buzzer
  -b- - disable buzzer
  -cl - clean nozzle
  -ca - calibrate bed
  -h - home printer
  -l - load filament
  -o num - increment/decrement z offset by num
  -u - unload filament
  -x num - jog x axis by num, or 10 if num not provided
  -y num - jog y axis by num, or 10 if num not provided
  -z num - jog z axis by num, or 10 if num not provided
This uses a modified version of the tiny-AES project by kkoke.
__https://github.com/kokke/tiny-AES-c__
It also uses a stripped down version of miniz by richgel999
__https://github.com/richgel999/miniz__
For downloading firmware from the website this also uses Internet.hpp from Elmü's code project
__https://www.codeproject.com/Articles/15397/Cabinet-File-CAB-Compression-and-Extraction__
and the simpleJSON library by MJPA.
__https://github.com/MJPA/SimpleJSON__
This is inspired by the threedub programs listed below but it is based on a fresh reverse engineering of the serial protocol.
__https://gitlab.com/anthem/py-threedub__
__https://gist.github.com/companje/b700748a49f4af73d57011c644f5a778__
__http://www.soliforum.com/topic/15639/jr-cura-230-threedub/__
__https://github.com/mwm/xyzify__
__https://www.thingiverse.com/thing:1915076__)

Show more
Feb 19
I'll fetch the documentation from the miniMover GitHub docs folder to understand the project thoroughly.


Fetched: miniMover/docs at master · reality-boy/miniMover
Fetched: miniMover/docs at master · reality-boy/miniMover

GitHub didn't render the file listing. Let me use the API to find the docs files.


Searched the web
Searched the web

Good, I found several doc files. Let me fetch them all.


Fetched: miniMover/docs/README.md at master · reality-boy/miniMover
Fetched: miniMover/docs/README.md at master · reality-boy/miniMover

GitHub isn't rendering the raw content. Let me fetch the raw files directly.


Searched the web
Searched the web


GitHub is blocking raw content in the rendered page. Let me clone the repo instead to get the actual files.


Viewed 4 files, ran a command
Viewed 4 files, ran a command
Now let me read the other key docs:


Viewed 2 files
Viewed 2 files
Now let me read the main library source to understand the code architecture:


Read the xyzv3.h header to understand the public API
Read the xyzv3.h header to understand the public API
Now let me look at the stream and serial abstractions:


Viewed 2 files
Viewed 2 files
Now let me check the socket header and the README:


Viewed 2 files
Viewed 2 files
Now let me quickly look at the printer list and the main xyzv3.cpp for the file encryption/conversion logic:


Read printer list definitions
Read printer list definitions
Let me look at the key parts of xyzv3.cpp — the file encryption, printer info array, and core protocol handling:


Ran a command, viewed a file
Ran a command, viewed a file
Now let me look at the encryption/decryption and upload sections:


Ran a command, viewed a file
Ran a command, viewed a file
I now have a thorough understanding of the project. Let me create a comprehensive analysis document.


Read the error codes doc
Read the error codes doc
Now I have a very thorough understanding of the entire miniMover project. Let me create the analysis document.


Check SKILL.md for markdown creation
Check SKILL.md for markdown creation
This is a knowledge review/analysis, not a document request — I'll create it as a markdown file.


Created a file, read a file
Created a file, read a file
Scott, I cloned the full miniMover repo and read through all the docs and source code. Here's what I've internalized — ready to build on:

The big picture: miniMover reverse-engineers XYZ's proprietary V3 serial protocol so you can bypass XYZware entirely. It sends standard GCode to printers that normally require encrypted .3w files, and handles all the printer control (calibration, filament, z-offset, etc.).

Key things I now know for building:

V3 Protocol — text commands over 115200 baud serial: XYZv3/query=, XYZv3/config=, XYZv3/action=, XYZv3/upload=. Responses terminate with $. State machine polls j:state,substate (9511 = idle).
3w file encryption — the keys are hardcoded (@xyzprinting.com for AES-128 CBC header/zip-body, doubled for AES-256 ECB non-zip body). IV is all zeros. PKCS7 padding. Body starts at offset 8192 in blocks of 0x2010 bytes.
Critical GCode gotcha — G0 must become G1, and the header needs ; machine = dv1MX0A000 (matching your printer model), ; print_time, and ; total_filament.
Upload protocol — 8KB chunked with big-endian 4-byte block number + size prefix, 4 null-byte suffix, ok acknowledgment per block.
24 supported printer models fully cataloged with model numbers, serial prefixes, build volumes, capabilities (WiFi, heated bed, dual extruder, laser, scanner).
The analysis doc has the complete protocol reference, state codes, error codes, file format structure, and encryption details. What would you like to build first?

Minimover analysis
Document · MD 
The goal is to not just have a functional printer again, but to ensure that the process and experience is streamlined. Open file in slicer, adust settings and slice, sent to printer. So what options do we have for slicers. do we build our own slicer and add this protocol in, does a slicer exist that we can add this protocol to? I would like to not use the minimover inbetween slicer and send to printer as an additional step.

Feb 19
Great question — let me research what's actually available for slicer integration before we decide on an approach.


Searched the web
Searched the web




This is really helpful — the Dremel Cura plugin is exactly the same kind of problem (proprietary format, custom protocol). Let me check one more option.


Searched the web
Searched the web

Now I have a really solid picture. Let me put together a clear options analysis.


Created a file, read a file
Created a file, read a file
Here's the bottom line, Scott:

Cura plugin is the clear winner. The Dremel community already solved the exact same problem — proprietary printer with an encrypted file format, no manufacturer software support — by building a Cura OutputDevicePlugin. It's in the Cura Marketplace and works great. We'd follow the same pattern.

The key advantages:

One-click workflow: Cura's plugin architecture has an OutputDevicePlugin API that puts a "Print to da Vinci" button right next to "Save to File" after slicing. Slice → click → encrypts → uploads → prints. No middleman.
Python, not C++. All of miniMover's protocol logic (serial comms, AES encryption with the known @xyzprinting.com keys, chunked upload) ports cleanly to Python using pyserial and pycryptodome. No compilation, easy to maintain.
Printer profiles baked in. We define the miniMaker's bed size (150³), nozzle, temps, and speeds in a JSON definition file. Cura uses those during slicing automatically — students don't have to think about it.
Classroom deployable. Install Cura, drag-drop the .curapackage plugin, select "da Vinci miniMaker" as your printer, done.
The PrusaSlicer route falls apart because it has no plugin system for output devices — you'd always need a separate sender tool, breaking your streamlined goal. OctoPrint adds unnecessary hardware. Building a slicer from scratch is a non-starter.

Want to start building the Cura plugin? I'd suggest Phase 1 first: printer definition files + a GCode writer that exports valid .3w files (so students can at least save-to-USB-drive immediately), then Phase 2 adds the live USB serial send.

Slicer integration options
Document · MD 
I intended the usb connection to be between the PC with the slicer and the minimaker via usb cable. revise plan for that

Feb 19
That's already what Option A describes — the Cura plugin would send directly from the PC to the miniMaker over the USB cable using the V3 serial protocol. Let me clarify the document so there's no ambiguity.


Edited 4 files, read a file
Edited 4 files, read a file
Updated. To be clear — the plan was always PC → USB cable → miniMaker, same connection XYZware used. The miniMaker shows up as a USB serial device at 115200 baud, and the Cura plugin would open that serial port directly using pyserial, no intermediary hardware.

The phasing is now:

Phase 1: The full end-to-end experience — auto-detect printer on USB, slice, encrypt, upload, print, all from one "Print to da Vinci" button
Phase 2: Printer control panel (filament load/unload, calibrate, z-offset)
Phase 3: Support for other da Vinci models and WiFi-equipped variants
Ready to start building Phase 1 when you are.

Slicer integration options
Document · MD 
start Phase 1

Feb 19
Let me start by studying the Dremel plugin structure as our template, then build the Cura plugin.


Searched the web
Searched the web

Good — I have a solid understanding of the Cura plugin architecture. Now let me look at the actual Cura USBPrinting plugin code to understand the OutputDevice pattern for direct USB serial, then build the full plugin.


Fetched: Cura/plugins/USBPrinting/USBPrinterOutputDevice.py at main · Ultimaker/Cura
Fetched: Cura/plugins/USBPrinting/USBPrinterOutputDevice.py at main · Ultimaker/Cura

GitHub rendered HTML again. Let me clone just the relevant Cura plugin files.


Viewed 4 files, ran a command
Viewed 4 files, ran a command
Now I have a thorough understanding of the plugin architecture. This is a large multi-file project — let me build it systematically.


Created 2 files, ran a command
Created 2 files, ran a command
Now the core V3 serial protocol module:


V3 serial protocol implementation — commands, queries, status parsing, file upload
V3 serial protocol implementation — commands, queries, status parsing, file upload
Let me check the transcript for where we left off, then continue building.


Ran a command, viewed a file
Ran a command, viewed a file
Good — we have plugin.json, __init__.py, and XYZProtocol.py done. Still need the .3w file converter, the device manager, the output device, and the printer definition files. Let me continue building.


Created 3 files
Created 3 files
Now the printer definition files:


Created 5 files
Created 5 files
Now let me add a README and the install script, then package everything:


README with installation and usage instructions
README with installation and usage instructions
Now let me verify everything is structurally sound and do a basic syntax check:


Ran 2 commands
Ran 2 commands
Now let me test the core logic that doesn't need a printer — the file converter:


Ran 2 commands
Ran 2 commands
Expected — Cura provides PyQt6, we just need to test the converter directly:


Ran 2 commands
Ran 2 commands
All tests pass. Now let me also test the protocol module's static methods:


Ran 2 commands
Ran 2 commands
That works standalone. The issue was the multi-field . split parsing. Let me check:


Find the bug — firmware version with dots gets split by the multi-field parser
Find the bug — firmware version with dots gets split by the multi-field parser
Found it — the . split for multi-field lines breaks firmware version strings like 1.3.5. The . separator is only used when multiple fields are on one line (like j:9530,11.t:1,205,210). I need to be smarter about the split.


Ran 3 commands, edited a file
Ran 3 commands, edited a file
All tests pass. Now let me package everything and create the output:


Ran 3 commands, read a file
Ran 3 commands, read a file
Phase 1 is built and tested. Here's what you have — 12 files, ~1,220 lines of Python:

The pipeline (what happens when you click "Print to da Vinci"):

XYZDeviceManager scans USB serial ports every 5s, finds the miniMaker by VID/PID
XYZOutputDevice registers a "Print to da Vinci" button in Cura's UI
On click → grabs sliced GCode from Cura scene
XYZFileConverter preprocesses: converts all G0→G1, injects XYZ header comments, AES-encrypts into .3w format
XYZProtocol uploads via V3 chunked protocol: 8KB blocks over USB serial at 115200 baud
Progress bar in Cura during upload, success/error messages at completion
What passed testing here:

✅ .3w file structure (magic, version, tag markers, offsets)
✅ AES-256-ECB encryption (non-zip, for miniMaker)
✅ AES-128-CBC encryption (zip variant, for older models)
✅ G0→G1 conversion
✅ XYZ header injection
✅ Cura print info extraction (time, filament, layers)
✅ V3 status response parsing (state, temps, firmware version with dots)
✅ Multi-field line parsing (j:9530,11.t:1,205,210)
What needs real-printer testing:

Serial port auto-detection (VID/PID matching on actual hardware)
Upload handshake timing (ok acknowledgments)
Print quality settings may need tuning per your specific printer
To install: Copy the XYZDaVinciPlugin folder into Cura's plugins directory, copy the resources/ subfolders to their matching Cura resource paths, and restart Cura. The README has exact paths per OS. You'll also need pycryptodome (pip install pycryptodome) if it's not bundled with your Cura install.

Readme
Document · MD 
init
PY 
Plugin
Code · JSON 
Xyzprotocol
PY 
Xyzfileconverter
PY 
Xyzoutputdevice
PY 
Xyzdevicemanager
PY 
Xyz davinci minimaker.def
Code · JSON 
Xyz davinci minimaker extruder.def
Code · JSON 
Xyz minimaker normal.inst
CFG 
Xyz minimaker fine.inst
CFG 
Xyz minimaker draft.inst
CFG 
Create a simple “module dependency map” for your code (internal imports) and keep it updated. then start phase 2

Feb 19

Ran 2 commands, viewed a file
Ran 2 commands, viewed a file
Good, I have the full picture. Now let me create the dependency map and then build Phase 2.


Module dependency map — internal imports, external deps, and data flow
Module dependency map — internal imports, external deps, and data flow
Now Phase 2 — printer control panel. Let me check what protocol commands we already have and what needs to be added:


See current public methods on XYZProtocol
See current public methods on XYZProtocol
Need to add: filament load/unload, calibrate, clean nozzle, jog, z-offset adjust. Then the OutputDevice needs to expose those to Cura, and we need a control panel UI.


Add filament load/unload, calibrate, clean nozzle, jog, z-offset, and query_print_progress to XYZProtocol
Add filament load/unload, calibrate, clean nozzle, jog, z-offset, and query_print_progress to XYZProtocol
Now add the control methods to XYZOutputDevice and update its imports:


Update XYZOutputDevice imports to include new protocol constants for state tracking
Update XYZOutputDevice imports to include new protocol constants for state tracking
Now add the printer control methods and an enhanced monitor to XYZOutputDevice:


Add Phase 2 printer control methods and enhanced status monitor to XYZOutputDevice
Add Phase 2 printer control methods and enhanced status monitor to XYZOutputDevice
Now update the version headers across all files:


Edited 2 files, ran a command
Edited 2 files, ran a command
Now syntax-check everything and run the tests again:


Ran 2 commands
Ran 2 commands
Now update the dependency map with Phase 2 additions:


Update dependency map with Phase 2 control methods and data flow
Update dependency map with Phase 2 control methods and data flow
Now copy the updated files to outputs:


Ran a command, read a file
Ran a command, read a file
Phase 2 is complete. Here's what changed:

DEPENDENCY_MAP.md — The ASCII-art dependency diagram shows every internal import, every external dep, every export, and all three data flows (print job, status monitor, printer control). This stays at the repo root and gets updated with each phase.

XYZProtocol.py (445 → 545 lines) — Added 12 new commands:

jog(axis, dir, dist) — move axes manually
load_filament_start/cancel — filament load with heating
unload_filament_start/cancel — filament retract
calibrate_start/detector_ok/release — 3-step bed calibration
clean_nozzle_start/cancel — heated nozzle cleaning
z_offset_up/down/get/set — first-layer height tuning
query_print_progress() — percent/elapsed/remaining
query_temperature() — live extruder temp
XYZOutputDevice.py (331 → 679 lines) — Added 13 public control methods:

loadFilament() / unloadFilament() — each runs in a background thread, polls state every 2s, shows live progress messages ("Heating...", "Loading...", "Complete!")
homeAxes() — homes all axes with wait-for-idle
jogAxis(axis, dir, dist) — quick axis movement
calibrateBed() — full calibration sequence with detector prompts
cleanNozzle() — heated clean cycle
adjustZOffset(dir) / getZOffset() — z-offset tuning
getPrinterStatus() — returns full status dict for UI
cancelPrint() / pausePrint() / resumePrint() — job control
Enhanced _monitor_loop() — now does full query_status() and pushes live temps into Cura's PrinterOutputModel
All methods follow the same pattern: check connected + not printing → launch background thread → send protocol command → poll state every 2s → show Cura Message toasts for progress/completion/errors. No new dependencies added.

Dependency map
Document · MD 
Xyzoutputdevice
PY 
Xyzprotocol
PY 
what if I can not download cura to my work pc... is there a way to test connection or is there a workaround we can develop?

8:10 AM
Good call — let's build a standalone test tool that uses the same XYZProtocol.py and XYZFileConverter.py modules (the two that have zero Cura dependencies) so you can verify everything works with your actual printer before Cura is even in the picture.


Viewed a file, created a file, ran a command
Viewed a file, created a file, ran a command
Now update the dependency map with the test tool:


Edited a file, ran a command, read a file
Edited a file, ran a command, read a file
Here's what you've got — a 706-line interactive CLI that exercises every protocol feature without needing Cura installed.

Setup on your work PC:

pip install pyserial pycryptodome
Run it:

python xyz_test_tool.py
It uses importlib to load XYZProtocol.py and XYZFileConverter.py directly, bypassing the __init__.py that triggers Cura/PyQt6 imports. Zero Cura dependencies.

What you can test with the printer plugged in:

Option 1 — Scan for printers: Detects serial ports, shows VID/PID matches, lets you pick one
Option 2 — Manual connect: Type COM3 or /dev/ttyUSB0 directly
Option 4 — Full status: Pretty-printed box showing model, firmware, temps, state, z-offset, filament, everything
Option 8 — Live monitor: Single-line refreshing display of state/temp/progress (Ctrl+C to stop)
Options 10-16 — All Phase 2 controls: Home, jog, load/unload filament, calibrate bed, clean nozzle, z-offset adjust — all with live status polling and cancel support
Option 20 — Offline .3w conversion: Convert any .gcode file to .3w without a printer connected at all — good for verifying the encryption works
Option 21 — Upload & print: Accepts .gcode (auto-converts to .3w) or raw .3w files, shows a progress bar during upload
This is the first thing to try when you plug the miniMaker in. Start with option 1 (scan), then 4 (full status). If that works, you know the entire protocol stack is solid and Cura integration is just UI wrapping.

Xyz test tool
PY 
Dependency map
Document · MD 
can we make a slicer app that does not require that I install on windows... can it run locally somehow and communicate over usb but I do not have admin rights to install a windows app. I have windows Windows 11 Enterprise 24H2 26100.7840 Windows Feature Experience Pack 1000.26100.291.0    Intel(R) Core(TM) i5-14500 (2.60 GHz) 16.0 GB (15.7 GB usable) 64-bit operating system, x64-based processor.

8:43 AM
Great constraint to work around. Let me think through this carefully.


Searched the web
Searched the web

Good question — let me break down what's actually possible given your constraints.


Searched the web
Searched the web



Now let me check what slicing engine options exist that could be bundled portably:


Searched the web
Searched the web

Now let me check the biggest potential blocker — the USB driver situation:


Searched the web
Searched the web

Good, I have enough information. Let me think through this thoroughly and give you an honest assessment plus a plan.

Okay, here's the honest breakdown. There are three hurdles, and the good news is all three have workable paths.

Hurdle 1: Python runtime — ✅ Solvable, no admin

Python's "Windows embeddable package" is just a .zip file you extract to any folder — no installer, no admin, no registry changes. You unzip it to C:\Users\scott\Python, run get-pip.py to bootstrap pip, and install packages locally. This runs completely in your user space.

Hurdle 2: USB serial driver — ⚠️ The real question mark

The miniMaker presents itself as a USB CDC-ACM serial device (VID 0x28E7, PID 0x0301). Windows 10+ ships with usbser.sys which is the built-in CDC serial driver. The key question is: has the printer ever been plugged into that PC before? If XYZware was previously installed, the driver is already loaded. If not, Windows 11 should auto-recognize it as a generic COM port — CDC-ACM is a standard USB class and usbser.sys is inbox. But in an Enterprise environment, Group Policy might block new device installation.

Here's how to test: Just plug the printer in. Open PowerShell (no admin needed) and run:

powershell
[System.IO.Ports.SerialPort]::GetPortNames()
```
If you see a new COM port appear, you're golden — no driver install needed.

**Hurdle 3: Slicer engine — ✅ Solvable, and this is the creative part**

We don't need the full Cura GUI. CuraEngine is a standalone `.exe` that takes an STL file and spits out GCode from the command line. We can bundle a pre-built CuraEngine.exe alongside our tool. But even simpler — we can build a **browser-based UI** that runs entirely locally:

**The plan: Portable all-in-one app**

I can build a self-contained folder you put on a USB stick or in your Documents:
```
DaVinciPrint/
  python/                  ← Embeddable Python (~15MB zip)
  CuraEngine.exe           ← Pre-built slicer binary
  cura-resources/          ← Printer definitions, settings
  XYZDaVinciPlugin/        ← Our protocol + converter code
  app.py                   ← Local web server (Flask/bottle)
  templates/               ← Browser UI (load STL, pick quality, print)
  START.bat                ← Double-click to launch
The workflow would be:

Double-click START.bat
Browser opens to http://localhost:8080
Drag-drop STL file → pick quality (fine/normal/draft) → preview
Click "Slice & Print" → CuraEngine slices → our code encrypts → uploads to printer
Live status monitor in the browser
No installer, no admin, no Cura GUI. The whole thing runs from a folder.

Before I build all that though, we need to verify the USB question first. Want to try plugging the printer in and running that PowerShell command? That determines whether we need to work around the driver issue or if we're clear to build the full portable app.

Test confirmed: plugging the printer in and running that PowerShell command resulting in a new COM port appearing, it was called COM3

8:58 AM
That's the big one — USB works without admin. We're clear to build the full portable app.

Let me build the complete self-contained package. I'll start with the web UI and local server, then the CuraEngine integration and the bootstrap scripts.


Viewed 6 files, ran a command
Viewed 6 files, ran a command
Good, I have the full picture. Now let me build the portable app — web server + browser UI + bootstrap scripts.


Ran 2 commands
Ran 2 commands
Now create the web server — this is the heart of the app:


Main web server — local Flask-like app (using built-in http.server to avoid extra deps). Handles STL upload, slicing via CuraEngine, conversion to .3w, and USB upload. Also serves printer status API for live monitoring.
Main web server — local Flask-like app (using built-in http.server to avoid extra deps). Handles STL upload, slicing via CuraEngine, conversion to .3w, and USB upload. Also serves printer status API for live monitoring.
Now the browser UI — this is the main interface students and you will interact with:


Viewed a file, created a file
Viewed a file, created a file
Now create the Windows bootstrap scripts:


Created 3 files
Created 3 files
Now let me verify everything compiles and the server starts:


Ran 3 commands
Ran 3 commands
Port scan crashed because serial.tools isn't imported in this test context. Let me fix the import issue and add a try/catch:


Fix serial.tools import in XYZProtocol detect_xyz_ports
Fix serial.tools import in XYZProtocol detect_xyz_ports
Also fix the same issue in the original plugin copy:


Edited a file, ran a command
Edited a file, ran a command
All endpoints working. Now let me create the wheels/ folder with a readme, create placeholder directories, and package everything up:


Create placeholder dirs with readme files
Create placeholder dirs with readme files
Now update the dependency map:


Add DaVinciPrint portable app to dependency map
Add DaVinciPrint portable app to dependency map
Now copy everything to outputs:


Ran 2 commands, read a file
Ran 2 commands, read a file
Here's the complete portable app. Your setup steps on the work PC:

One-time setup (~5 min):

Download the whole DaVinciPrint/ folder to C:\Users\YourName\Documents\DaVinciPrint\
Go to python.org → Downloads → Windows → grab the "Windows embeddable package (64-bit)" zip (~11MB)
Extract that zip into DaVinciPrint\python\ (you should see python\python.exe)
Double-click SETUP.bat — it patches the ._pth file, downloads pip, installs pyserial + pycryptodome
Daily use:

Plug in the miniMaker
Double-click START.bat
Browser opens to localhost:8080 — three-panel interface:
Left: Connection panel (scan → click COM3 → connected), printer controls (home, filament load/unload, pause/cancel)
Center: Drag-drop .STL or .GCode file, pick quality, click "Slice & Print"
Right: Live status (state, temperature, progress ring, error codes)
Two workflows depending on CuraEngine:

With CuraEngine: Drop an STL → auto-slices → encrypts → uploads. To get CuraEngine, copy CuraEngine.exe and fdmprinter.def.json from any Cura installation (home PC, etc.) into cura-engine/
Without CuraEngine: Slice at home in any slicer, save the .gcode, bring it on a USB stick, drop it in the UI → encrypts → uploads. This works immediately with zero extra files.
The whole thing is ~2,400 lines of code, runs on localhost only, sends zero data to the internet, and needs no admin rights.

Readme
Document · MD 
App
PY 
Index
Code · HTML 
START.bat
 
SETUP.bat
 
I Clicked on python.exe and I got this: "Python 3.13.12 (tags/v3.13.12:1cbe481, Feb  3 2026, 18:22:25) [MSC v.1944 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
I clicked on SETUP.bat and it ran. 
I clicked on START.bat and this is what I got: ""ΓòöΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòù
  Γòæ   DaVinciPrint ΓÇö Portable 3D Printer Interface   Γòæ
  ΓòÜΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓò¥
  Using portable Python: python\python.exe
Traceback (most recent call last):
  File "C:\Users\ssandvik\Documents\DaVinciPrint\app.py", line 41, in <module>
    from XYZDaVinciPlugin.XYZProtocol import (
        XYZProtocol, XYZPrinterStatus, PRINTER_DB, STATE_NAMES
    )
ModuleNotFoundError: No module named 'XYZDaVinciPlugin'
Press any key to continue . . ." please advise

Show more
9:18 AM
The embeddable Python's ._pth file restricts where it looks for modules. We need to tell it to look in the app directory. Quick fix:


Fix module import — add explicit sys.path setup before importing our modules, so embeddable Python can find XYZDaVinciPlugin/
Fix module import — add explicit sys.path setup before importing our modules, so embeddable Python can find XYZDaVinciPlugin/
But the real issue is likely that SETUP.bat uncommented import site but didn't add the app directory to the ._pth file. Let me also update SETUP.bat to add . (current directory) to the path file:


Update SETUP.bat to also add current directory '.' to the ._pth file so embeddable Python can find local modules
Update SETUP.bat to also add current directory '.' to the ._pth file so embeddable Python can find local modules
Also update START.bat to set the working directory explicitly and pass app dir to Python:


Ran 2 commands, edited a file, read a file
Ran 2 commands, edited a file, read a file
Two things to do on your work PC:

1. Fix the ._pth file (since SETUP.bat already ran once without the fix):

Open PowerShell, navigate to your DaVinciPrint folder, and run:

powershell
$pth = Get-ChildItem python\python*._pth
$content = Get-Content $pth
if ($content -notcontains '.') { $content += '.'; $content | Set-Content $pth }
Get-Content $pth
You should see a line with just . at the end. That tells embeddable Python to look in the current directory.

2. Replace the three updated files — app.py, START.bat, SETUP.bat — with the new versions I just provided.

Then double-click START.bat again. The fix attacks from two angles: START.bat now sets PYTHONPATH pointing at the app folder, and app.py now explicitly inserts its own directory into sys.path before importing. Either one alone should be enough, but belt-and-suspenders given the embeddable Python quirks.

App
PY 
START.bat
 
SETUP.bat
 
ok here is the actual path C:\Users\ssandvik\Documents\DaVinciPrint is that actual path conflicting with the code and commands etc or is that what was used?

9:28 AM
That path is perfectly fine — no conflict at all. The code uses Path(__file__).parent.resolve() which dynamically discovers its own location at runtime, so it doesn't matter where you put the folder. The START.bat uses %~dp0 which is the batch file's own directory. Both are relative, not hardcoded.

The error you hit was purely about embeddable Python's ._pth file restricting its import search path — nothing to do with your folder location.

Did you get the three updated files replaced and the ._pth fix applied? Ready to try START.bat again?

PowerShell 7.5.4
PS C:\Users\ssandvik> [System.IO.Ports.SerialPort]::GetPortNames()
COM1
PS C:\Users\ssandvik> [System.IO.Ports.SerialPort]::GetPortNames()
COM1
COM3
PS C:\Users\ssandvik> $pth = Get-ChildItem python\python*._pth
Get-ChildItem: Cannot find path 'C:\Users\ssandvik\python' because it does not exist.
PS C:\Users\ssandvik> $content = Get-Content $pth
Get-Content: Cannot bind argument to parameter 'Path' because it is null.
PS C:\Users\ssandvik> if ($content -notcontains '.') { $content += '.'; $content | Set-Content $pth }
Set-Content: Cannot bind argument to parameter 'Path' because it is null.
PS C:\Users\ssandvik> $pth = Get-ChildItem python\python*._pth
Get-ChildItem: Cannot find path 'C:\Users\ssandvik\python' because it does not exist.
PS C:\Users\ssandvik> $pth = Get-ChildItem python\python*._pth
Get-ChildItem: Cannot find path 'C:\Users\ssandvik\python' because it does not exist.
PS C:\Users\ssandvik>

Show more
2:22 PM
You need to cd into the DaVinciPrint folder first — PowerShell is looking at C:\Users\ssandvik\ instead of where the python\ subfolder lives:

powershell
cd C:\Users\ssandvik\Documents\DaVinciPrint
$pth = Get-ChildItem python\python*._pth
$content = Get-Content $pth
if ($content -notcontains '.') { $content += '.'; $content | Set-Content $pth }
Get-Content $pth
```

The output should show something like:
```
python313.zip
.
import site
That . on its own line is the key part — it tells Python "also look in the current working directory for modules." Once that's there, replace the three updated files and try START.bat again.

PS C:\Users\ssandvik> cd C:\Users\ssandvik\Documents\DaVinciPrint
PS C:\Users\ssandvik\Documents\DaVinciPrint> $pth = Get-ChildItem python\python*._pth
PS C:\Users\ssandvik\Documents\DaVinciPrint> $content = Get-Content $pth
PS C:\Users\ssandvik\Documents\DaVinciPrint> if ($content -notcontains '.') { $content += '.'; $content | Set-Content $pth }
PS C:\Users\ssandvik\Documents\DaVinciPrint> Get-Content $pth
python313.zip
.
# Uncomment to run site.main() automatically
import site
PS C:\Users\ssandvik\Documents\DaVinciPrint>

  ΓòöΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòù
  Γòæ   DaVinciPrint ΓÇö Portable 3D Printer Interface   Γòæ
  ΓòÜΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓò¥
  Using portable Python: python\python.exe
Traceback (most recent call last):
  File "C:\Users\ssandvik\Documents\DaVinciPrint\app.py", line 46, in <module>
    from XYZDaVinciPlugin.XYZProtocol import (
        XYZProtocol, XYZPrinterStatus, PRINTER_DB, STATE_NAMES
    )
ModuleNotFoundError: No module named 'XYZDaVinciPlugin'
Press any key to continue . . .

Show more
2:25 PM
The ._pth file is overriding sys.path — the . resolves to wherever python.exe is (inside python\), not the app root. Let me fix app.py to use an absolute path that can't be overridden:


Use absolute path insertion at position 0 before any imports — this cannot be overridden by ._pth
Use absolute path insertion at position 0 before any imports — this cannot be overridden by ._pth
Also remove the now-redundant later imports that were already handled:


Ran 2 commands, edited a file, read a file
Ran 2 commands, edited a file, read a file
Replace just app.py and try START.bat again. The problem was that embeddable Python's . in the ._pth file resolves relative to python\python.exe — so it was searching DaVinciPrint\python\ for XYZDaVinciPlugin, not DaVinciPrint\. The fix now uses Path(__file__).parent.resolve() to get the absolute path to app.py's directory and injects that into sys.path before anything else runs.

App
PY 
ΓòöΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòù
  Γòæ   DaVinciPrint ΓÇö Portable 3D Printer Interface   Γòæ
  ΓòÜΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓò¥
  Using portable Python: python\python.exe
Traceback (most recent call last):
  File "C:\Users\ssandvik\Documents\DaVinciPrint\app.py", line 46, in <module>
    from XYZDaVinciPlugin.XYZProtocol import (
        XYZProtocol, XYZPrinterStatus, PRINTER_DB, STATE_NAMES
    )
ModuleNotFoundError: No module named 'XYZDaVinciPlugin'
Press any key to continue . . .

Show more
2:27 PM
Same error — the ._pth file is actively blocking sys.path modifications. Let me debug this properly. The issue is that embeddable Python ignores sys.path.insert() when a ._pth file is present and site isn't fully loaded yet.

Let me take a different approach — add a .pth file inside the python/ directory that points back to the app root:


Update SETUP.bat to create a .pth file inside python/Lib/site-packages that points to the app root — this is the proper way to add paths for embeddable Python
Update SETUP.bat to create a .pth file inside python/Lib/site-packages that points to the app root — this is the proper way to add paths for embeddable Python
But since SETUP already ran, also update START.bat to create the .pth file on every launch as a failsafe:


Update START.bat to ensure the .pth file exists before launching — belt and suspenders
Update START.bat to ensure the .pth file exists before launching — belt and suspenders
Also harden app.py with a sitecustomize approach — write a temp sitecustomize.py if needed:


Ran 2 commands, edited a file, read a file
Ran 2 commands, edited a file, read a file
Replace all three files. This version attacks the problem from three directions:

START.bat now creates python\Lib\site-packages\davinci.pth containing your app path on every launch — this is the officially supported way to add paths in embeddable Python
app.py creates python\sitecustomize.py on first run which injects the path at startup
app.py has a fallback except ModuleNotFoundError block that uses importlib.util.spec_from_file_location() to load the modules directly by absolute file path — this bypasses sys.path entirely
At least one of those three will work. Replace the files and try START.bat again.

App
PY 
START.bat
 
SETUP.bat
 





Claude is AI and can make mistakes. Please double-check responses.